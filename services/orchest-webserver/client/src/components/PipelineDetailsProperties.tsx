import * as React from "react";
import _ from "lodash";
import { Controlled as CodeMirror } from "react-codemirror2";
import "codemirror/mode/javascript/javascript";
import {
  extensionFromFilename,
  kernelNameToLanguage,
  makeCancelable,
  makeRequest,
  PromiseManager,
  RefManager,
  collapseDoubleDots,
} from "@orchest/lib-utils";
import { MDCSelectReact, MDCTextFieldReact } from "@orchest/lib-mdc";
import ProjectFilePicker from "../components/ProjectFilePicker";

const ConnectionItem = (props) => (
  <div className="connection-item" data-uuid={props.connection.uuid}>
    <i className="material-icons">drag_indicator</i>{" "}
    <span>{props.connection.name[0]}</span>{" "}
    <span className="filename">({props.connection.name[1]})</span>
  </div>
);

const KERNEL_OPTIONS = [
  ["python", "Python"],
  ["r", "R"],
  ["julia", "Julia"],
];

const PipelineDetailsProperties: React.FC<any> = (props) => {
  const { $, orchest } = window;

  const [state, setState] = React.useState({
    environmentOptions: [],
    // this is required to let users edit JSON (while typing the text will not be valid JSON)
    editableParameters: JSON.stringify(props.step.parameters, null, 2),
    autogenerateFilePath: props.step.file_path.length == 0,
  });

  const [promiseManager] = React.useState(new PromiseManager());
  const [refManager] = React.useState(new RefManager());

  const isNotebookStep = () =>
    extensionFromFilename(props.step.file_path) == "ipynb";

  const fetchEnvironmentOptions = () => {
    let environmentsEndpoint = `/store/environments/${props.project_uuid}`;

    if (isNotebookStep()) {
      environmentsEndpoint +=
        "?language=" + kernelNameToLanguage(props.step.kernel.name);
    }

    let fetchEnvironmentOptionsPromise = makeCancelable(
      makeRequest("GET", environmentsEndpoint),
      promiseManager
    );

    fetchEnvironmentOptionsPromise.promise
      .then((response) => {
        let result = JSON.parse(response);

        let environmentOptions = [];

        let currentEnvironmentInEnvironments = false;

        for (let environment of result) {
          if (environment.uuid == props.step.environment) {
            currentEnvironmentInEnvironments = true;
          }
          environmentOptions.push([environment.uuid, environment.name]);
        }

        if (!currentEnvironmentInEnvironments) {
          // update environment
          onChangeEnvironment(
            environmentOptions.length > 0 ? environmentOptions[0][0] : "",
            environmentOptions.length > 0 ? environmentOptions[0][1] : ""
          );
        }

        setState((prevState) => ({
          ...prevState,
          environmentOptions: environmentOptions,
        }));
      })
      .catch((error) => {
        console.log(error);
      });
  };

  const updateStepName = (step_uuid, title, file_path) =>
    props.onNameUpdate(step_uuid, title, file_path);

  const onChangeFileName = (updatedFileName, autogenerated) => {
    if (!autogenerated) {
      setState((prevState) => ({
        ...prevState,
        autogenerateFilePath: false,
      }));
    }
    let step = _.cloneDeep(props.step);
    step.file_path = updatedFileName;

    updateStepName(step.uuid, step.title, step.file_path);
    props.onSave(step);
  };

  const onChangeParameterJSON = (updatedParameterJSON) => {
    setState((prevState) => ({
      ...prevState,
      editableParameters: updatedParameterJSON,
    }));

    try {
      let step = _.cloneDeep(props.step);
      step.parameters = JSON.parse(updatedParameterJSON);
      props.onSave(step);
    } catch (err) {
      // console.log("JSON did not parse")
    }
  };

  const onChangeMemory = (updatedMemory) => {
    let step = _.cloneDeep(props.step);
    step.memory = updatedMemory;
    props.onSave(step);
  };

  const onChangeEnvironment = (
    updatedEnvironmentUUID,
    updatedEnvironmentName
  ) => {
    let step = _.cloneDeep(props.step);

    step.environment = updatedEnvironmentUUID;
    step.kernel.display_name = updatedEnvironmentName;

    props.onSave(step);
    if (updatedEnvironmentUUID !== "" && step["file_path"] !== "") {
      let kernelName = `orchest-kernel-${updatedEnvironmentUUID}`;

      orchest.jupyter.setNotebookKernel(
        collapseDoubleDots(props.pipelineCwd + step["file_path"]).slice(1),
        kernelName
      );
    }
  };

  const onChangeKernel = (updatedKernel) => {
    let step = _.cloneDeep(props.step);
    step.kernel.name = updatedKernel;
    props.onSave(step);
  };

  const titleToFileName = (title) => {
    const alphanumeric = /[^a-zA-Z0-9-]/g;
    title = title.replace(alphanumeric, "-");
    const concatDashes = /(-+)/g;
    title = title.replace(concatDashes, "-");
    if (title.slice(-1) == "-") {
      title = title.slice(0, -1);
    }
    title = title.toLowerCase();
    return title;
  };

  const onChangeTitle = (updatedTitle) => {
    let step = _.cloneDeep(props.step);
    step.title = updatedTitle;

    updateStepName(step.uuid, step.title, step.file_path);

    props.onSave(step);

    if (state.autogenerateFilePath) {
      // Make sure the props have been updated
      setTimeout(() => {
        onChangeFileName(titleToFileName(updatedTitle), true);
      }, 1);
    }
  };

  const swapConnectionOrder = (oldConnectionIndex, newConnectionIndex) => {
    // check if there is work to do
    if (oldConnectionIndex != newConnectionIndex) {
      let step = _.cloneDeep(props.step);

      // note it's creating a reference
      let connectionList = step.incoming_connections;

      let tmp = connectionList[oldConnectionIndex];
      connectionList.splice(oldConnectionIndex, 1);
      connectionList.splice(newConnectionIndex, 0, tmp);

      step.incoming_connections = connectionList;

      props.onSave(step);
    }
  };

  const setupConnectionListener = () => {
    // initiate draggable connections

    let previousPosition = 0;
    let connectionItemOffset = 0;
    let oldConnectionIndex = 0;
    let newConnectionIndex = 0;

    let numConnectionListItems = $(refManager.refs.connectionList).find(
      ".connection-item"
    ).length;

    $(refManager.refs.connectionList).on(
      "mousedown",
      ".connection-item",
      function (e) {
        previousPosition = e.clientY;
        connectionItemOffset = 0;

        $(refManager.refs.connectionList).addClass("dragging");

        oldConnectionIndex = $(this).index();

        $(this).addClass("selected");

        console.log(
          "[Assert] Should trigger once, otherwise listener duplication going on."
        );
      }
    );

    $(document).on("mousemove.connectionList", function (e) {
      let selectedConnection = $(refManager.refs.connectionList).find(
        ".connection-item.selected"
      );

      if (selectedConnection.length > 0) {
        let positionDelta = e.clientY - previousPosition;
        let itemHeight = selectedConnection.outerHeight();

        connectionItemOffset += positionDelta;

        // limit connectionItemOffset
        if (connectionItemOffset < -itemHeight * oldConnectionIndex) {
          connectionItemOffset = -itemHeight * oldConnectionIndex;
        } else if (
          connectionItemOffset >
          itemHeight * (numConnectionListItems - oldConnectionIndex - 1)
        ) {
          connectionItemOffset =
            itemHeight * (numConnectionListItems - oldConnectionIndex - 1);
        }

        selectedConnection.css({
          transform: "translateY(" + connectionItemOffset + "px)",
        });

        previousPosition = e.clientY;

        // find new index based on current position
        let elementYPosition =
          (oldConnectionIndex * itemHeight + connectionItemOffset) / itemHeight;

        newConnectionIndex = Math.min(
          Math.max(0, Math.round(elementYPosition)),
          numConnectionListItems - 1
        );

        // evaluate swap classes for all elements in list besides selectedConnection
        for (let i = 0; i < numConnectionListItems; i++) {
          if (i != oldConnectionIndex) {
            let connectionListItem = $(refManager.refs.connectionList)
              .find(".connection-item")
              .eq(i);

            connectionListItem.removeClass("swapped-up");
            connectionListItem.removeClass("swapped-down");

            if (newConnectionIndex >= i && i > oldConnectionIndex) {
              connectionListItem.addClass("swapped-up");
            } else if (newConnectionIndex <= i && i < oldConnectionIndex) {
              connectionListItem.addClass("swapped-down");
            }
          }
        }
      }
    });

    // Note, listener should be unmounted
    $(document).on("mouseup.connectionList", function (e) {
      let selectedConnection = $(refManager.refs.connectionList).find(
        ".connection-item.selected"
      );

      if (selectedConnection.length > 0) {
        selectedConnection.css({ transform: "" });
        selectedConnection.removeClass("selected");

        $(refManager.refs.connectionList)
          .find(".connection-item")
          .removeClass("swapped-up")
          .removeClass("swapped-down");

        $(refManager.refs.connectionList).removeClass("dragging");

        swapConnectionOrder(oldConnectionIndex, newConnectionIndex);
      }
    });
  };

  React.useEffect(() => {
    if (!props.readOnly) {
      // set focus on first field
      refManager.refs.titleTextField.focus();
      setupConnectionListener();
    }

    fetchEnvironmentOptions();

    return () => {
      promiseManager.cancelCancelablePromises();
      $(document).off("mouseup.connectionList");
      $(document).off("mousemove.connectionList");
    };
  }, []);

  React.useEffect(() => fetchEnvironmentOptions(), [
    props?.step?.file_path,
    props?.step?.kernel?.name,
  ]);

  return (
    <div className={"detail-subview"}>
      <div className="input-group">
        <MDCTextFieldReact
          value={props.step.title}
          onChange={onChangeTitle.bind(this)}
          label="Title"
          disabled={props.readOnly}
          classNames={["fullwidth", "push-down"]}
          ref={refManager.nrefs.titleTextField}
        />

        <div className="push-down">
          {props.readOnly ? (
            <MDCTextFieldReact
              value={props.step.file_path}
              label="File name"
              disabled={props.readOnly}
              classNames={["fullwidth", "push-down"]}
            />
          ) : (
            <ProjectFilePicker
              cwd="/"
              value={props.step.file_path}
              project_uuid={props.project_uuid}
              pipeline_uuid={props.pipeline_uuid}
              step_uuid={props.step.uuid}
              onChange={onChangeFileName.bind(this)}
            />
          )}
        </div>

        <MDCSelectReact
          label="Kernel language"
          onChange={onChangeKernel.bind(this)}
          options={KERNEL_OPTIONS}
          value={props.step.kernel.name}
          disabled={props.readOnly}
          classNames={(() => {
            let classes = ["push-down", "fullwidth"];
            if (!isNotebookStep()) {
              classes.push("hidden");
            }
            return classes;
          })()}
        />

        <MDCSelectReact
          label="Environment"
          disabled={props.readOnly}
          classNames={["fullwidth"]}
          onChange={onChangeEnvironment.bind(this)}
          options={state.environmentOptions}
          value={props.step.environment}
        />
      </div>

      <div className="input-group">
        <h3>Parameters</h3>

        <CodeMirror
          value={state.editableParameters}
          options={{
            mode: "application/json",
            theme: "jupyter",
            lineNumbers: true,
            readOnly: props.readOnly === true, // not sure whether CodeMirror accepts 'falsy' values
          }}
          onBeforeChange={(editor, data, value) => {
            onChangeParameterJSON(value);
          }}
        />

        {(() => {
          try {
            JSON.parse(state.editableParameters);
          } catch {
            return (
              <div className="warning push-up push-down">
                <i className="material-icons">warning</i> Your input is not
                valid JSON.
              </div>
            );
          }
        })()}
      </div>

      {props.step.incoming_connections.length != 0 && (
        <div className="input-group">
          <h3>Connections</h3>

          <div
            className="connection-list"
            ref={refManager.nrefs.connectionList}
          >
            {props.step.incoming_connections.map((item, key) => (
              <ConnectionItem
                connection={{
                  name: props.connections[item],
                  uuid: item,
                }}
                key={key}
              />
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default PipelineDetailsProperties;
